# 5 Работа со Списками

Мы уже познакомились с несколькими списочными функциями --- `min`, `max`,
`mean` --- и использовали их для анализа табличных данных. Ранее, в пункте
4.3.1 (Списки как Анонимные Данные), мы уже выяснили, что

- некоторые списочные функции работают на любых списках, независимо от того,
  значения какого типа в этих списках содержатся: например, для функции, которая
  вычисляет размер списка, тип значений никакой роли не играет;

- другие же специфичны для какого-то конкретного типа данных: функция суммы
  предполагает, что в списке будут содержаться числа;

- и есть ещё те, которые находятся где-то между двумя предыдущими: функция
  вычисления максимального значения будет работать с любыми сравниваемыми
  значениями, такими как строки или числа.

Несмотря на кажущееся разнообразие различных видов функций, существует, к
счастью, единый способ написания таких функций, общий для каждой из них. Цель
настоящей главы для нас --- понять и усвоить этот способ.

## <a name=5.1>5.1</a> Составление Списков и Их Разбиение

До настоящего момента мы видели только один способ создания списка: `[list:
...]`. Несмотря на удобность, этот способ записи скрывает от нас истинную
природу списков. На самом деле, каждый список состоит из двух частей: _первый_
(`first`) элемент и _все остальные_ (`rest`) элементы списка. Все остальные
элементы по сути тоже являются списком, который в свою очередь также состоит из
двух частей... и т. д.

Рассмотрим список `[list: 1, 2, 3]`. Его первый элемент это `1`, а все
остальные --- это `[list: 2, 3]`. Теперь рассмотрим второй список, его первый
элемент есть `2`, а остаток --- `[list: 3]`. Для третьего списка мы имеем: `3`
как первый элемент и `[list: ]` --- т. е. пустой список --- как остаток. В
Pyret пустой список также можно записывать как `empty`.

Сейчас мы разбили список на части вручную, но в Pyret, конечно, есть
специальные для этого операции. Списки являются примером _структурированных
данных_, и, вообще говоря, есть два способа разобрать структурированные
данные на части: использовать либо `cases` (об этом мы узнаем позднее), либо
использовать _свойства_ (accessors). У списка есть два свойства: `first` и
`rest`. Чтобы воспользоваться свойством, нужно написать выражение, за которым
должна следовать точка, после которой пишется имя свойства.

```
l1 = [list: 1, 2, 3]
h1 = l1.first
l2 = l1.rest
h2 = l2.first
l3 = l2.rest
h3 = l3.first
l4 = l3.rest

check:
  h1 is 1
  h2 is 2
  h3 is 3
  l2 is [list: 2, 3]
  l3 is [list: 3]
  l4 is empty
end
```

Так `first` и `rest` позволяют нам разбить список на части. Можно ли
так же --- по частям --- не разбирать, а собирать новый список? Оказывается,
можно. `link` --- это функция (называемая _конструктором_), которая создаёт
списки. Она принимает два аргумента: (первый) элемент создаваемого списка и
список, в котором содержатся все остальные элементы списка. Тогда `l1` из
примера выше можно получить, последовательно применяя функцию `link`:

```
check:
  [list: 1, 2, 3] is link(1, link(2, link(3, empty)))
end
```

Можно таким образом считать, что существует всего два вида списков. Каждый
список является либо 

- пустым (записывается как `empty` или `[list: ]`), либо

- непустым (записывается как `link(..., ...)` или `[list: ...]`.

## 5.2 Примеры

Чтобы лучше понять, как работают функции на списках, рассмотрим несколько
конкретных примеров. Каждая из этих функций принимает список, а некоторые из
них не только принимают списки, но и возвращают их. Т. к. некоторые из этих
функций уже существуют в языке, мы добавляем к именам функций префикс `my-`,
чтобы избежать конфликта имён.

- Вычислить длину списка: `my-len :: List<Any> -> Number`

- Вычислить сумму списка (чисел): `my-sum :: List<Number> -> Number`

- Вычислить максимум списка (чисел или строк): `my-max :: List<Any> -> Any`

- Принимая список строк, сконвертировать каждую строку в число, равное длине этой строки: `my-str-len :: List<String> -> List<Number>`

- Принимая список чисел, сгенерировать список положительных чисел из данного списка: `my-pos-nums :: List<Number> -> List<Number>`

- Принимая список чисел, заменить каждый элемент списка суммой элементов с первого элемента до данного включительно: `my-running-sum :: List<Number> -> List<Number>`

- Принимая список чисел, выбрать числа через одно, начиная с первого: `my-alternating :: List<Any> -> List<Any>`

- Принимая список чисел, вычислить среднее значение этих чисел: `my-avg :: List<Number> -> Number`

Чтобы решить эти и подобные этим задачи, нам нужно сделать две вещи:

- привести примеры использования функции (на каких аргументах что возвращает);

- определить по этим примерам _закономерность_, на основе которой можно будет
  построить решение.

## 5.3 Структурные Задачи со Скалярными Ответами

Давайте напишем несколько примеров для функций, описанных выше. Писать примеры
мы будем специфическим для этих функций способом: прежде всего, нужно написать
два примера --- один с `empty`, а другой --- с как минимум одним `link`-ом;
таким образом, мы покрываем все возможные списки в том широком смысле, о
котором было сказано в конце пункта 5.1. Далее нам нужно написать примеры,
которые основываются на типе списка, описанного в задаче. После этого мы ещё
должны добавить несколько примеров для иллюстрации того подхода, которым мы
собираемся решать данную задачу.

### 5.3.1 `my-len`: Примеры

До настоящего момента не было точно определено, что такое «длина» списка. Мы
сталкиваемся с этим вопросом сразу же, при попытке записать первый пример: какова
длина `empty`? Если записать `empty` как `[list: ]`, то становится очевиднее,
что это список из _нуля_ элементов, т. к. в квадратных скобках ничего не
записано, поэтому мы полагаем

```
my-len(empty) is 0
```

Что насчёт `[list: 7]`? Ясно, что там один элемент --- `7`, и значит

```
my-len([list: 7]) is 1
```

Аналогично для списка `[list: 7, 8, 9]` положим

```
my-len([list: 7, 8, 9]) is 3
```

Теперь давайте остановимся на последнем примере и посмотрим на него с другой
стороны. Рассмотрим аргумент `[list: 7, 8, 9]`. Его первый элемент это `7`,
остальные элементы --- `[list: 8, 9]`. Первый элемент не явлется списком,
однако все остальные элементы список образуют, поэтому мы можем задать вопрос о
его длине. Чему равно `my-len([list: 8, 9])`? В списке два элемента, поэтому

```
my-len([list: 8, 9]) is 2
```

Первый элемент _этого_ списка --- число `8`, остальные элементы --- список
`[list: 9]`.

```
my-len([list: 9]) is 1
```

Все элементы данного списка без первого элемента образуют, очевидно, пустой
список --- `empty`, чья длина равна нулю. Составляя вместе все эти примеры, получаем:

```
my-len([list: 7, 8, 9]) is 3
my-len([list:    8, 9]) is 2
my-len([list:       9]) is 1
my-len([list:        ]) is 0
```

Можно переписать эти примеры несколько иным способом:

```
my-len([list: 7, 8, 9]) is 1 + 2
my-len([list:    8, 9]) is 1 + 1
my-len([list:       9]) is 1 + 0
my-len([list:        ]) is     0
```

Глядя на примеры, записанные таким способом, можно увидеть закономерность.
Длина пустого списка равна `0`. Длина непустого списка равна сумме единицы `1`
(«вклад» первого элемента в общую длину списка) и длины списка, состоящего из
остальных элементов. Таким образом

```
my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list:    8, 9]) is 1 + my-len([list:    9])
my-len([list:       9]) is 1 + my-len([list:     ])
my-len([list:        ]) is 0
```

Т. е. мы можем использовать результат вычисления длины списка без первого
элемента для вычисления длины всего списка.

### 5.3.2 `my-sum`: Примеры

Ту же самую логику мы применяем для анализа `my-sum`. Чему равна сумма
списка `[list: 7, 8, 9]`? Разумеется, нам бы хотелось, чтобы она была равна
`24`. Согласимся также и с тем, что сумма `[list: 8, 9]` равна `17`, а `[list:
9]` --- `9`. Тогда имеем

```
my-sum([list: 7, 8, 9]) is 7 + 8 + 9
my-sum([list:    8, 9]) is     8 + 9
my-sum([list:       9]) is         9
```

что можно также переписать как

```
my-sum([list: 7, 8, 9]) is 7 + my-sum([list: 8, 9])
my-sum([list:    8, 9]) is 8 + my-sum([list:    9])
my-sum([list:       9]) is 9 + my-sum([list:     ])
```

Из последнего примера очевидно следует, что `my-sum([list: ])` равно
нулю

```
my-sum([list: ]) is 0
```

### 5.3.3 От Примеров к Коду

Получившиеся примеры мы можем теперь обратить в код. Для этого мы введём
конструкцию **cases**, с помощью которой мы можем различать разные виды списков
и выбирать на основе этих различий выражения, которые должны быть исполнены.

Шаблон `cases` для списков выглядит так:

```
cases (List) lst:
  | empty          => ...
  | link(fst, rst) => ... fst ... rst ...
end
```

большая часть этого кода остаётся неизменной при каждом использовании. Изменять
здесь вы можете 

- `lst` --- выражение, чьим значением должен быть список; это должна быть либо
  переменная, связанная со списком, либо комплексное выражение, которое
  вычисляется до списка;

- `fst` и `rst` --- имена для первого элемента и остальных элементов списка. Вы
  можете выбрать любые имена, какие вам хочется, однако в Pyret принято
  записывать их как `fst` и `rst` либо как `f` и `r` соответственно.

Справа от каждого `=>` записано выражение.

В данном случае `cases` работает следующим образом. Pyret сперва вычисляет
значение `lst`. Затем он проверяет, действительно ли получившееся значение
является списком; если это не так, то выполнение программы прерывается вызовом
ошибки. Если данное значение является списком, Pyret определяет, какой _вид_ у
этого списка. Если это пустой список, то выполняется выражение справа от `=>`
там, где слева от `=>` написано `empty`. Если это непустой список, то Pyret
связывает `fst` и `rst` соответственно с первым элементом и остальными
элементами этого непустого списка, и затем выполняет выражение справа от `=>` в
пункте с `link`.

Используем теперь `cases` для определения `my-len`:

```
fun my-len(lst):
  cases (List) lst:
    | empty          => 0
    | link(fst, rst) => 1 + my-len(rst)
  end
end
```

этот код явно следует из наших примеров: когда список пустой, `my-len`
возвращает `0`; когда он непустой, мы прибавляем единицу к длине списка без
первого элемента (здесь он обозначен через `rst`)

Аналогично определим `my-sum`:

```
fun my-sum(lst):
  cases (List) lst:
    | empty          => 0
    | link(fst, rst) => fst + my-sum(rst)
  end
end
```

## 5.4 Структурные Задачи с Ответами в Виде Списка

Теперь давайте займёмся функциями, которые должны производить список в качестве
ответа.

### 5.4.1 `my-str-len`: Примеры и Код

Как обычно, начнём с примеров. Получая список строк, мы хотим из него сделать
список длин этих строк (в том же самом порядке). Допустим, есть такой пример:

```
my-str-len([list: "hi", "there", "mateys"]) is [list: 2, 5, 6]
```

ответы для подзадач будут такими:


```
my-str-len([list:       "there", "mateys"]) is [list:    5, 6]
my-str-len([list:                "mateys"]) is [list:       6]
```

или, другими словами, 

```
my-str-len([list: "hi", "there", "mateys"]) is link(2, [list: 5, 6])
my-str-len([list:       "there", "mateys"]) is link(5, [list:    6])
my-str-len([list:                "mateys"]) is link(6, [list:     ])
```

из чего следует, что ответом на пустой список должен быть пустой список:

```
my-str-len(empty) is empty
```

Эти ответы мы можем получить применяя `string-length` последовательно к каждому
элементу списка:

```
fun my-str-len(lst):
  cases (List) lst:
    | empty => empty
    | link(fst, rst) =>
        link(string-length(fst), my-str-len(rst))
  end
end
```

### 5.4.2 `my-pos-nums`: Примеры и Код

И снова начнём с примеров:

```
my-pos-nums([list: 1, -2, 3, -4]) is [list: 1, 3]
my-pos-nums([list:    -2, 3, -4]) is [list:    3]
my-pos-nums([list:        3, -4]) is [list:    3]
my-pos-nums([list:           -4]) is [list:     ]
my-pos-nums([list:             ]) is [list:     ]
```

Можно переписать их с использованием `link`:

```
my-pos-nums([list: 1, -2, 3, -4]) is link(1, [list: 3])
my-pos-nums([list:    -2, 3, -4]) is         [list: 3]
my-pos-nums([list:        3, -4]) is link(3, [list: ])
my-pos-nums([list:           -4]) is         [list: ]
my-pos-nums([list:             ]) is         [list: ]
```

или, более явно,

```
my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])
my-pos-nums([list:             ]) is         [list: ]
```

Т. е. когда первый элемент положителен, мы добавляем его к результату
вычисления `my-pos-nums` на остальных элементах; когда первый элемент
отрицателен, мы берём лишь результат вычисления `my-pos-nums` на остальных
элементах. Это даёт нам следующий код:

```
fun my-pos-nums(lst):
  cases (List) lst:
    | empty => empty
    | link(fst, rst) =>
        if fst > 0:
          link(fst, my-pos-nums(rst))
        else:
          my-pos-nums(rst)
        end
  end
end
```

Является ли наш набор примеров исчерпывающим? Не вполне. Есть ещё много
примеров, которые мы не рассматривали: списки, оканчивающиеся положительными
числами, списки с `0` внутри. 

_Упражнение: разберите эти примеры и сравните правильные ответы с теми, которые
будет выдавать программа._

### <a name=5.4.3>5.4.3</a> `my-alternating`: Попытка Первая

Итак, примеры:

```
check:
  my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
  my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
  my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
  my-alternating([list:          4, 5, 6]) is [list:    4, 6]
end
```

Внимательно посмотрите на первые два. Каждый из них записан правильно, но
_второй ответ никак не помогет нам получить первый_. Это может означать, что
способа, которым мы решали задачи до этого момента, недостаточно, и здесь ещё
есть, над чем подумать. Вернёмся к этой задаче позже.

### <a name=5.4.4>5.4.4</a> `my-running-sum`: Попытка Первая

И ещё раз начинаем с примеров. Запишем первые три:

```
check:
  my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
  my-running-sum([list:    2, 3, 4, 5]) is [list: 2, 5, 9, 14]
  my-running-sum([list:       3, 4, 5]) is [list: 3,  7, 12]
end
```

здесь снова не видно ясной связи между первыми двумя ответами. Эту задачу мы также
пока пропускаем.

## 5.5 Структурные Задачи с Ограниченной Областью Применения

### 5.5.1 `my-max`: Примеры

Давайте теперь найдём максимальное значение в списке. Для простоты будем
считать, что список --- это список чисел. Примеры каких списков нам нужно
построить? Сначала, конечно, пустой и непустой списки. А что ещё? Будет ли
`[list: 1, 2, 3]` хорошим примером? Этот пример подойдёт, но нам также
следует рассмотреть списки, где максимум находится в начале списка, а не в
конце; максимум может быть в середине; максимум может встречаться в списке
более одного раза; максимум может быть отрицательным числом; и т. д. 

```
my-max([list: 1, 2, 3]) is 3
my-max([list: 3, 2, 1]) is 3
my-max([list: 2, 3, 1]) is 3
my-max([list: 2, 3, 1, 3, 2]) is 3
my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list: -2, -1, -3]) is -1
```

Как определить `my-max(empty)`? Будет ли оно равно нулю?

Вернёмся к этому вопросу позже.

Перед тем как продолжить, полезно узнать, что существует такая функция как
`num-max`, которая уже есть в Pyret, сравнивающая два числа

```
num-max(1, 2) is 2
num-max(-1, -2) is -1
```

Посмотрим теперь на `my-max` в действии:

```
my-max([list: 1, 2, 3]) is 3
my-max([list:    2, 3]) is 3
my-max([list:       3]) is 3
```

Кажется, этот пример никак не приближает нас к решению. И мы всё ещё не знаем,
что делать с `empty`.

Следующий пример

```
my-max([list: 3, 2, 1]) is 3
my-max([list:    2, 1]) is 2
my-max([list:       1]) is 1
```

также не сообщает нам ничего о том, как может выглядеть потенциальное решение.
Возможно, мы не видим общей закономерности из-за неудачного --- или, точнее
сказать, неполного --- набора примеров.

Давайте посмотрим на ещё один

```
my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list:    1, 4, 3, 2]) is 4
my-max([list:       4, 3, 2]) is 4
my-max([list:          3, 2]) is 3
my-max([list:             2]) is 2
```

Обратите внимание, как, вычисляя максимум списка без первого элемента, мы
получаем один из двух аргументов для `num-max`, а сравнивая его и первый элемент,
получаем конечный ответ.

```
my-max([list: 2, 1, 4, 3, 2]) is num-max(2, 4)
my-max([list:    1, 4, 3, 2]) is num-max(1, 4)
my-max([list:       4, 3, 2]) is num-max(4, 3)
my-max([list:          3, 2]) is num-max(3, 2)
my-max([list:             2]) is ...
```

Последний пример можно было бы записать как

```
my-max([list:             2]) is num-max(2, ...)
```

однако мы не знаем, что есть максимум (или минимум, или любой другой элемент)
пустого списка. Поэтому, пропуская последний пример, имеем следующее:

```
my-max([list: 2, 1, 4, 3, 2]) is num-max(2, my-max([list: 1, 4, 3, 2]))
my-max([list:    1, 4, 3, 2]) is num-max(1, my-max([list:    4, 3, 2]))
my-max([list:       4, 3, 2]) is num-max(4, my-max([list:       3, 2]))
my-max([list:          3, 2]) is num-max(3, my-max([list:          2]))
```

Теперь видно, как мы можем использовать ответ для части списка, чтобы получить
ответ для всего списка, который, в свою очередь, может также являться частью
какого-нибудь другого списка, и т. д.

В конце концов, нам надо разобраться с тем, как обрабатывать случай списка
`empty`. Проблема заключается в том, что в пустом списке нет максимального
элемента, т. к. в нём нет вообще никаких элементов. Т. е. бессмысленно задавать
вопрос о максимуме пустого списка: понятие «максимума» определено только для
непустых списков. Поэтому при попытке вычислить максимум пустого списка нам следует 
сообщить об ошибке с помощью `raises`:

```
my-max(empty) raises ""
```

### 5.5.2 `my-max`: От Примеров к Коду

На основе примеров выше мы можем написать такой код:

```
fun my-max(lst):
  cases (List) lst:
    | empty          => raise("не определено для пустых списков")
    | link(fst, rst) => num-max(fst, my-max(rst))
  end
end
```

Рассмотрим пример со списком `[list: 2]`. При выполнении `my-max([list: 2])`
программа попытается вычислить `num-max(2, my-max([list: ]))`, что, очевидно,
приведёт к ошибке. Таким образом, ни на каком непустом списке наша функция
работать не будет. Чтобы это исправить, нам нужно правильно определять, не
пытаемся ли мы найти максимум в пустом списке. Сделать это можно двумя
способами. О первом из них пойдёт речь прямо сейчас, а другой мы обсудим
позднее.

Обращаясь вновь к примерам, мы видим, что, перед тем как выполнять `my-max(rst)`,
нам нужно проверить, является ли `rst` из `link(fst, rst)` пустым списком. Если он
пуст, то `my-max` на нём выполнять не следует. Если список `rst` --- `lst` без
первого элемента --- пуст, то максимумом списка `lst` мы считаем его первый и
единственный элемент `fst`:

```
fun my-max(lst):
  cases (List) lst:
    | empty          => raise("не определено для пустых списков")
    | link(fst, rst) =>
        cases (List) rst:
          | empty => fst
          | ...
        end
  end
end
```

Осталось написать, что нужно сделать, если `lst` и `rst` оба непусты. Если
список `lst` непуст, то --- как видно опять же из примеров --- мы должны вычислить
максимум списка `rst` и сравнить его с первым элементом --- `fst`:

```
fun my-max(lst):
  cases (List) lst:
    | empty          => raise("не определено для пустых списков")
    | link(fst, rst) =>
        cases (List) rst:
          | empty => fst
          | else  => num-max(fst, my-max(rst))
        end
  end
end
```

_Упражнение: убедитесь в правильности этого определения._

### <a name=5.5.3>5.5.3</a> `my-alternating`: Примеры и Код

Возвращаясь к <a href=#5.4.3>5.4.3 `my-alternating`: Попытка Первая</a>, мы
видим, что нам нужны не все примеры, а лишь _каждый второй_ пример. Проблема в том, что при
переходе от одного примера к следующему мы должны удалять из списка сразу _два_
элемента, а не один --- как будто элементы в списке стоят не по одиночке, а
парами. Выглядеть это будет так:

```
my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
my-alternating([list:             5, 6]) is [list:       5]
my-alternating([list:                 ]) is [list:        ]
```

Поэтому строить нашу программу мы будем так: оставляем первый элемент,
пропускаем второй элемент, повторяем. Начать можем с такого шаблона:

```
fun my-alternating(lst):
  cases (List) lst:
    | empty          => empty
    | link(fst, rst) => link(fst, ... rst ...)
  end
end
```

_Упражнение: не читая код ниже, попробуйте самостоятельно дополнить этот шаблон
кода до рабочего решения._

Перед тем как продолжить, заметим, что выбранный пример недостаточно хорош для
того, чтобы в полной мере отразить в себе все возможные варианты списков, которые
могут нам встретиться. Например, для того, чтобы оставить один элемент и один элемент
пропустить, нам нужны _два_ элемента, которых, вообще говоря, может и не быть:
список может содержать нечётное число элементов. Т. е. может быть что-то такое:

```
my-alternating([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 5]
my-alternating([list:       3, 4, 5]) is [list:    3, 5]
my-alternating([list:             5]) is [list:       5]
```

Это означает, что _мы не всегда будем получать в конце пустой список_. Нужно
быть готовыми к тому, что в конце получится список с одним элементом. Учитывая
это обстоятельство, завершаем определение функции:

```
fun my-alternating(lst):
  cases (List) lst:
    | empty          => empty
    | link(fst, rst) =>
        cases (List) rst: # заметьте --- раскладываем rst, а не lst
          | empty        => [list: fst] # в списке нечётное число элементов
          | link(fr, rr) => link(fst, my-alternating(rr)) # fr --- первый элемент rst, rr --- rst без первого элемента
        end
  end
end
```

В [<a href=#5.6.2>5.6.2</a>] мы увидим ещё один способ решения этой задачи.

### 5.5.4 `my-avg`: Примеры

Давайте теперь попробуем посчитать среднее арифметическое списка чисел. Начнём
с примера `[list: 1, 2, 3, 4]` и выведем другие примеры из него. Среднее
арифметическое этих чисел равно `(1 + 2 + 3 + 4) / 4`, или `10/4`.

Остатком данного списка будет список `[list: 2, 3, 4]`, а уже его остатком ---
`[list: 3, 4]`, и т. д. Для этих списков получаем такие примеры:

```
my-avg([list: 1, 2, 3, 4]) is 10/4
my-avg([list:    2, 3, 4]) is 9/3
my-avg([list:       3, 4]) is 7/2
my-avg([list:          4]) is 4/1
```

Проблема заключается в том, что по этим примерам не видно, как от ответа для
подсписка можно перейти к ответу для всего списка. Другими словами, зная, что 

- среднее арифметическое остатка равно `9/3`, или `3`,

- и первое число в списке --- это `1`

как мы можем из этого вывести, что среднее арифметическое всего списка равно
`10/4`? Оказывается, никак. Чтобы в этом убедиться, рассмотрим более простой
пример.

Предположим, что первое число в списке это `1`, а среднее остатка этого списка
равно `2`. Вот два разных списка, каждый из которых удовлетворяет указанным
условиям:

```
[list: 1, 2]    # в остатке один элемент с суммой, равной двум
[list: 1, 4, 0] # в остатке два элемента с суммой, равной четырём
```

Среднее первого списка равно `3/2`, тогда как среднее второго списка равно
`5/3`. 

Таким образом, для получения ответа знание среднего арифметического остатка
списка нам никак не нужно, а нужно вместо этого знать сумму элементов и их
количество. И тогда, чтобы посчитать среднее для всего списка, нам достаточно
прибавить первый элемент к этой сумме, а количество элементов увеличить на
единицу.

В принципе, мы могли бы вычислять всю эту информацию в теле `my-avg`, но вместо
этого будет гораздо проще разбить эту задачу на две части (подсчёт суммы и
количества) и использовать уже написанные нами для этого функции:

```
fun my-avg(l):
  my-sum(l) / my-len(l)
end
```

_Упражнение: подумайте, чему будет равно среднее пустого списка? Будет ли
функция, определённая выше, давать тот ответ, который вы ожидаете?_

Так же, как и в случае с максимумом, значение функции на пустом списке не
вполне определено. Поэтому было бы логично здесь вызвать ошибку. Так совпало,
что в коде выше ошибка вызывается, но неявным образом: ошибка возникает при
попытке поделить на нуль. И всё же, вместо того, чтобы надеяться на другие
функции (в данном случае --- деление), лучше самим явно обозначить эту ситуацию
(`l` --- пустой список) и вызвать соответствующую ошибку.

_Упражнение: измените функцию `my-avg` так, чтобы при передаче ей пустого
списка, она вызывала ошибку._

Таким образом, мы видим, что наш подход к решению путём прямой конвертации
примеров в код не всегда оказывается достаточным, и нам приходится прибегать к
более сложным механизмам для получения полноценного решения. Однако, заметьте,
что сам этот подход помогает нам быстро _обнаружить_ ситуации, в которых он не
работает.

## 5.6 Структурные Задачи с Аккумуляторами

Теперь можно заняться пропущенными задачами. Для их решения потребуется новая
техника.

### 5.6.1 `my-running-sum`: Примеры и Код

Вспомним, с чего мы начали в [<a href=#5.4.4>5.4.4</a>]. На
примерах стала видна следующая проблема. Когда мы обрабатываем остаток списка,
мы забываем всё, что было до него. Т. е. когда мы начинаем работать со списком,
который начинается с `2`, мы уже забыли, что перед этим в списке был `1`; когда
обрабатываем список, начинающийся с `3`, мы не помним, что уже видели `1` и
`2`, и т. д.  Нам нужно найти способ избежать это забывание.

Самое простое, что можно сделать, --- это изменить функцию так, чтобы она
сохраняла эту «память», которую мы ещё называем _аккумулятором_. Представьте,
что мы определяем новую функцию `my-rs`. Она получает список чисел и возвращает
список чисел, но вместе с этим она _также получает сумму чисел, предшествоваших
текущему списку_.

Изначально никаких «предшествующих чисел» нет, поэтому мы начнём с `0`. Функция
`my-rs` имеет такой тип:

```
my-rs :: Number, List<Number> -> List<Number>
```

Давайте теперь переработаем примеры `my-running-sum` из [<a
href=#5.4.4>5.4.4</a>] под `my-rs`:

```
my-rs( 0, [list: 1, 2, 3, 4, 5]) is [list:  0 + 1] + my-rs( 0 + 1, [list: 2, 3, 4, 5])
my-rs( 1, [list:    2, 3, 4, 5]) is [list:  1 + 2] + my-rs( 1 + 2, [list:    3, 4, 5])
my-rs( 3, [list:       3, 4, 5]) is [list:  3 + 3] + my-rs( 3 + 3, [list:       4, 5])
my-rs( 6, [list:          4, 5]) is [list:  6 + 4] + my-rs( 6 + 4, [list:          5])
my-rs(10, [list:             5]) is [list: 10 + 5] + my-rs(10 + 5, [list:           ])
my-rs(15, [list:              ]) is empty
```

По этим примерам получаем следующий код:

```
fun my-rs(acc, lst):
  cases (List) lst:
    | empty => empty
    | link(fst, rst) =>
        new-sum = acc + fst
        link(new-sum, my-rs(new-sum, rst))
  end
end
```

И всё, что нам остаётся сделать, --- это вызвать `my-rs` из `my-running-sum`:

```
fun my-running-sum(lst):
  my-rs(0, lst)
end
```

_Упражнение: подумайте, почему мы не стали изменять саму `my-running-sum`
добавлением к ней дополнительного параметра._

### <a name=5.6.2>5.6.2</a> `my-alternating`: Примеры и Код

В [<a href=#5.5.3>5.5.3</a>] мы уже решили эту задачу, убирая из списка по два
элемента за один раз. Другой способ решить эту же задачу --- убирать из списка
по одному элементу за раз, но при этом _запоминать, на каком мы сейчас элементе
--- на чётном или нечётном_. Т. е. как бы добавить «память» в нашу программу.
Т. к.  нам нужно различать только два значения (чётный, нечётный), достаточно
будет воспользоваться типом `Boolean`. Тип у вспомогательной функции будет
такой:

```
my-alt :: List<Any>, Boolean -> List<Any>
```

Дополнительный аргумент будет определять, нужно ли нам пропускать текущий
элемент или нужно включать его в итоговый список.

Если аккумулятор равен `true`, мы включаем текущий элемент в список, в
противном случае --- игнорируем. При обработке остальных элементов (`rst`) списка
необходимо обновлять аккумулятор: если мы сохранили текущий элемент, то нужно
проигнорировать следующий, и наоборот.

```
fun my-alt(lst, keep):
  cases (List) lst:
    | empty => empty
    | link(fst, rst) =>
        if keep:
          link(fst, my-alt(rst, false))
        else:
          my-alt(rst, true)
  end
end
```

Нам осталось лишь определить, чему должен быть равен аккумулятор при первом
вызове. Т. к. мы хотим получить каждый второй элемент, _начиная с первого_,
первым значением аккумулятора должно быть `true`:

```
fun my-alternating(lst):
  my-alt(lst, true)
end
```

## 5.7 Задачи с Неоднозначным Ответом

Во всех обсуждаемых до этого задачах предполагалось, что для каждых входных
данных существует только один правильный ответ. Зачастую действительно так и
есть, однако это также зависит от того, как сформулирована задача, и от того, как мы
подбираем примеры.

### 5.7.1 `uniq`: Постановка Задачи

Рассмотрим задачу создания функции `uniq`: получая список значений, она должна
производить набор элементов данного списка без учёта повторений (поэтому и
`uniq` --- от слова _unique_). (Кстати, в GNU/Linux существует утилита с тем же
названием, которая делает то же самое.)

Рассмотрим такие входные данные: `[list: 1, 2, 1, 3, 1, 2, 4, 1]`.

_Упражнение: если этот список выбрать в качестве первого примера, то какими
будут следующие? Прежде чем читать дальше, попробуйте сами построить эту
цепочку примеров, явно проговаривая, как вы будете переходить от одного примера
к другому._

### 5.7.2 `uniq`: Примеры

Оказывается, существует _несколько_ правильных ответов, потому что мы
(умышленно) не уточнили условие задачи. Предположим, что в списке есть два
одинаковых значения; какое из них мы должны оставить --- первое или второе?  С
одной стороны, это неважно, потому что они одинаковы; с другой стороны, это
важно, потому что от этого выбора зависит то, как будут записаны конкретные
примеры, из которых потом будет выведено решение.

Допустим, вы составили такую цепочку примеров:

```
examples:
  uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:    2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:       1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:          3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:             1, 2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                   4, 1]) is [list:       4, 1]
  uniq([list:                      1]) is [list:          1]
  uniq([list:                       ]) is [list:           ]
end
```

Но вы также могли бы начать цепочку с такого примера:

```
uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 1, 2, 3, 4]
```

или такого:

```
uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 4, 3, 2, 1]
```

и т. д. Давайте разберём первый пример.

### 5.7.3 `uniq`: Код

Какой именно подход приводит нас к такому ответу? Когда мы получаем непустой
список, мы разбиваем его на первый элемент (`fst`) и на все остальные элементы
(`rst`).  Предположим, у нас есть ответ на `uniq(rst)`. Теперь можно спросить:
содержится ли первый элемент в `rst`? Если так, то мы его игноририуем, т. к. он
точно будет в `uniq(rst)`; если же это не так, то мы должны добавить его с
помощью `link` к итоговому ответу.

Из этого рассуждения получается такая программа. Для пустого списка мы
возвращаем пустой список. Если список непуст, мы проверяем, содержится ли
первый элемент в остатке списка. Если нет, мы включаем его; иначе ---
игнорируем.

```
fun uniq-rec(lst :: List<Any>) -> List<Any>:
  cases (List) lst:
    | empty => empty
    | link(fst, rst) =>
        if rst.member(fst):
          uniq-rec(rst)
        else:
          link(fst, uniq-rec(rst))
        end
  end
end
```

Мы пишем `uniq-req` вместо `uniq`, чтобы отличать её от других версий `uniq`,
которые мы ещё напишем.

_Упражнение: заметьте, что мы используем свойство `.member`, чтобы проверить,
содержится ли элемент в списке. Напишите функцию `member`, которая, получая
на вход элемент и список, говорит, содержится ли данный элемент в данном
списке._

### 5.7.4 `uniq`: Сокращение Вычислений

Как вы видите, в функции `uniq-req` есть повторяющееся выражение. Вместо того,
чтобы писать его два раза, мы можем вычислить его один раз и использовать
результат в двух местах:

```
fun uniq-rec2(lst :: List<Any>) -> List<Any>:
  cases (List) lst:
    | empty => empty
    | link(fst, rst) =>
        ur = uniq-rec2(rst)
        if rst.member(fst):
          ur
        else:
          link(fst, ur)
        end
  end
end
```

Можно подумать, что раз мы заменили два вызова функции одним, мы тем самым
уменьшили количество вычислений, которые сделает программа. На самом деле, это
не так. Оба вызова функции находились в разных ветках одного условного
выражения; поэтому, каким бы ни был элемент `fst`, всегда будет выполнен только
один вызов `uniq`. Таким образом, мы уменьшили количество вызовов функции
только в тексте программы, а на деле --- при выполнении программы --- это
количество осталось неизменным.

Тем не менее, есть всё-таки одно полезное упрощение, которые мы можем сделать.
Сейчас мы проверяем, содержится ли `fst` в `rst`, который является списком
_всех_ остальных элементов. Для нашего примера это значит, что на втором шаге
мы проверяем, есть ли `2` в списке `[list: 1, 3, 1, 2, 4, 1]`. Этот список
состоит из шести элементов, среди которых есть три копии `1`. Мы сравним `2` с
_двумя_ копиями `1`, хотя второе сравнение ничего нового нам не даёт. Чтобы
этого избежать, мы можем проверять вхождение элемента не в `rst`, а в
`uniq(rst)`, который по сути является тем же списком `rst`, но без лишних
копий, и этим самым мы сможем избежать лишних сравнений.

```
fun uniq-rec3(lst :: List<Any>) -> List<Any>:
  cases (List) lst:
    | empty => empty
    | link(fst, rst) =>
        ur = uniq-rec3(rst)
        if ur.member(fst):
          ur
        else:
          link(fst, ur)
        end
  end
end
```

### 5.7.5 `uniq`: Варианты Примеров и Кода

Как было сказано ранее, есть и другие варианты примеров, которые вы могли бы
выписать. Вот ещё один подход, которым можно решать эту задачу:

- Начинаем с изначального входного списка и пустого ответа.

- Для каждого элемента списка проверяем, содержится ли он в ответе. Если да, то
  игнорируем его; если нет --- добавляем его к ответу.

- Когда элементов в исходном списке больше нет, возвращаем получившийся ответ.

Данный подход предполагает использование аккумулятора. Мы считаем
_естественным_ решением то, которое основывается исключительно на структуре
данных (отсюда и «структурные задачи»); если этого оказывается недостаточно, то
мы прибегаем к помощи аккумуляторов. Т. к. в данном случае естественного
решения достаточно, нет нужды использовать аккумулятор; к тому же, его
использование значительно усложнит выписывание примеров (попробуйте написать
несколько).

### 5.7.6 `uniq`: Почему Список?

Если вы вернётесь к изначальной формулировке задаче о `uniq`, то увидите, что
там ничего не сказано о том, в каком порядке должны быть записаны элементы в
ответе. Там даже не сказано, что ответом должен быть список (и, следовательно,
что там должен быть хоть какой-то порядок). Здесь нужно подумать о том, имеет
ли вообще смысл использование списка в данной задаче. Если нам не важен
порядок, и мы не хотим учитывать повторяющиеся элементы, проще всего будет
производить в качестве ответа не список, а _множество_. В Pyret уже встроены
множества, и при конвертации из списка во множество автоматически удаляются все
копии. Это, конечно, читерство, и никак не способствует самостоятельному
решению задачи `uniq`, однако стоит помнить о том, что иногда нужная структура
данных не совпадает с той, которую нам дают.

## 5.8 Мономорфные Списки и Полиморфные Типы

Ранее мы писали контракты типа таких:

```
my-len :: List<Any> -> Number
my-max :: List<Any> -> Any
```

Рассмотрим `my-max`. В контракте говорится, что любой (`Any`) тип элемента
может быть в списке, однако это неверно: список `[list: 1, "two", 3]` не
является валидным, потому что мы не можем сравнить `1` и `"two"` или `"two` и
`3`.


_Упражнение: что произойдёт, если выполнить `1 > "two"` или `"two" > 3`?_

В контракте не учитывается то, что в списке должны быть элементы только одного
типа. Также мы не считаем, что `my-max` может возвращать значение произвольного
типа. Если мы ищем максимальное среди чисел, то мы никак не можем получить в
результате строку. Функция должна возвращать тот тип элемента, который указан у
списка.

Короче говоря, хочется сказать, что все элементы в списке должны быть одного
типа, но этот тип может быть произвольным. Поэтому мы называем списки
_мономорфными_: «моно» значит один, а «морф» значит форма, т. е. у всех
значений один тип. Но функция `my-max` может обрабатывать списки разных типов,
поэтому мы называем её _полиморфной_ («поли» значит много).

Поэтому нам нужен более точный способ написания таких контрактов. Существует
такая вещь как _переменная типа_ (в отличие от обычной переменной), которая
представляет тип элемента в списке. Получая этот тип, `my-max` вернёт значение
именно этого типа. Записывается это следующим образом:

```
fun my-max<T>(l :: List<T>) -> T: … end

```

Нотация `<T>` означает, что `T` это параметр переменной типа, который будет
использоваться в данной функции (как в заголовке, так и в теле).

Используя эту нотацию, можем пересмотреть `my-len`, теперь она будет выглядеть так:

```
fun my-len<T>(l :: List<T>) -> Number: … end
```

Заметьте, что `my-len` в действительности не проверяет, обладают ли все
элементы списка одним и тем же типом. Она никогда не смотрит на отдельные
элементы, а уж тем более на пары элементов. Однако, мы _уславливаемся_ о том,
что списки всегда будут мономорфными. Это важно, т. к. тогда мы сможем
единообразно обрабатывать все элементы списка: если мы знаем, как обрабатывать
элементы типа `T`, то мы также знаем, как обрабатывать `List<T>`. Если бы тип
каждого из элементов списка мог быть произвольным, то мы бы не знали, как
обрабатывать такой список.
