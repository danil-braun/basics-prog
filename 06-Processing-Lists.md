# 5 Работа со Списками

Мы уже познакомились с несколькими списочными функциями --- `min`, `max`,
`mean` --- и использовали их для анализа табличных данных. Ранее, в пункте
4.3.1 (Списки как Анонимные Данные), мы уже выяснили, что

- некоторые списочные функции работают на любых списках, независимо от того,
  значения какого типа в этом списке содержатся: например, для функции, которая
  вычисляет размер списка, тип значений никакой роли не играет;

- другие же специфичны для какого-то конкретного типа данных: функция суммы
  предполагает, что в списке будут содержаться числа;

- и есть ещё те, которые находятся где-то между двумя предыдущими: функция
  вычисления максимального значения будет работать с любыми сравниваемыми
  значениями, такими как строки или числа.

Несмотря на кажущееся разнообразие различных видов функций, существует, к
счастью, единый способ написания таких функций, общий для каждой из них. Цель
настоящей главы для нас --- понять и усвоить этот способ.

## <a name=5.1>5.1</a> Составление Списков и Их Разбиение

До настоящего момента мы видели только один способ создания списка: `[list:
...]`. Несмотря на удобность, этот способ записи скрывает от нас их истинную
натуру. На самом деле, каждый список состоит из двух частей: _первый_ (`first`)
элемент и _все остальные_ (`rest`) элементы списка. Все остальные элементы по
сути тоже являются списком, который в свою очередь также состоит из двух
частей... и т. д.

Рассмотрим список `[list: 1, 2, 3]`. Его первый элемент это `1`, а все
остальные --- это `[list: 2, 3]`. Теперь рассмотрим второй список, его первый
элемент есть `2`, а остаток --- `[list: 3]`. Для третьего списка мы имеем: `3`
как первый элемент и `[list: ]` --- т. е. пустой список --- как остаток. В
Pyret пустой список также можно записывать как `empty`.

Сейчас мы разбили список на части вручную, но в Pyret, конечно, есть
специальные для этого операции. Списки являются примером _структурированных
данных_, и, вообще говоря, есть два способа разобрать структурированные
данные на части: использовать либо `cases` (об этом мы узнаем позднее), либо
использовать _свойства_ (accessors). У списка есть два свойства: `first` и
`rest`. Чтобы воспользоваться свойством, нужно написать выражение, за которым
должна следовать точка, после которой пишется имя свойства.

```
l1 = [list: 1, 2, 3]
h1 = l1.first
l2 = l1.rest
h2 = l2.first
l3 = l2.rest
h3 = l3.first
l4 = l3.rest

check:
  h1 is 1
  h2 is 2
  h3 is 3
  l2 is [list: 2, 3]
  l3 is [list: 3]
  l4 is empty
end
```

Так `first` и `rest` позволяют нам разбить список на части. Можно ли
так же --- по частям --- не разбирать, а собирать новый список? Оказывается,
можно. `link` --- это функция (называемая _конструктором_), которая создаёт
списки. Она принимает два аргумента: (первый) элемент создаваемого списка и
список, в котором содержатся все остальные элементы списка. Тогда `l1` из
примера выше можно получить, последовательно применяя функцию `link`:

```
check:
  [list: 1, 2, 3] is link(1, link(2, link(3, empty)))
end
```

Можно таким образом считать, что существует всего два вида списков. Каждый
список является либо 

- пустым (записывается как `empty` или `[list: ]`), либо

- непустым (записывается как `link(..., ...)` или `[list: ...]`.

## 5.2 Примеры

Чтобы лучше понять, как работают функции на списках, рассмотрим несколько
конкретных примеров. Каждая из этих функций принимает список, а некоторые из
них не только принимают списки, но и возвращают их. Т. к. некоторые из этих
функций уже существуют в языке, мы добавляем к именам функций префикс `my-`,
чтобы избежать конфликта имён.

- Вычислить длину списка: `my-len :: List<Any> -> Number`

- Вычислить сумму списка (чисел): `my-sum :: List<Number> -> Number`

- Вычислить максимум списка (чисел или строк): `my-max :: List<Any> -> Any`

- Принимая список строк, сконвертировать каждую строку в число, равное длине этой строки: `my-str-len :: List<String> -> List<Number>`

- Принимая список чисел, сгенерировать список положительных чисел из данного списка: `my-pos-nums :: List<Number> -> List<Number>`

- Принимая список чисел, заменить каждый элемент списка суммой элементов с первого элемента до данного включительно: `my-running-sum :: List<Number> -> List<Number>`

- Принимая список чисел, выбрать числа через одно, начиная с первого: `my-alternating :: List<Any> -> List<Any>`

- Принимая список чисел, вычислить среднее значение этих чисел: `my-avg :: List<Number> -> Number`

Чтобы решить эти и подобные этим задачи, нам нужно сделать две вещи:

- Привести примеры поведения функции (на каких аргументах что возвращает).

- Использовать _шаблон_, который  TODO

## 5.3 Структурные Задачи со Скалярными Ответами TODO

Давайте напишем несколько примеров для функций, описанных выше. Писать примеры
мы будем специфическим для этих функций способом: прежде всего, нужно написать
два примера --- один с `empty`, а другой --- с как минимум одним `link`-ом;
таким образом, мы покрываем все возможные списки в том широком смысле, о
котором было сказано в конце пункта 5.1. Далее нам нужно написать примеры,
которые основываются на типе списка, описанного в задаче. После этого мы ещё
должны добавить несколько примеров для иллюстрации того подхода, которым мы
собираемся решать данную задачу.

### 5.3.1 `my-len`: Примеры

До настоящего момента не было точно определено, что такое «длина» списка. Мы
сталкиваемся с этим вопросом сразу же, при попытке записать первый пример: какова
длина `empty`? Если записать `empty` как `[list: ]`, то становится очевиднее,
что это список из _нуля_ элементов, т. к. в квадратных скобках ничего не
записано, поэтому мы полагаем

```
my-len(empty) is 0
```

Что насчёт `[list: 7]`? Ясно, что там один элемент --- `7`, и значит

```
my-len([list: 7]) is 1
```

Аналогично для списка `[list: 7, 8, 9]` положим

```
my-len([list: 7, 8, 9]) is 3
```

Теперь давайте остановимся на последнем примере и посмотрим на него с другой
стороны. Рассмотрим аргумент `[list: 7, 8, 9]`. Его первый элемент это `7`,
остальные элементы --- `[list: 8, 9]`. Первый элемент не явлется списком,
однако все остальные элементы список образуют, поэтому мы можем задать вопрос о
его длине. Чему равно `my-len([list: 8, 9])`? В списке два элемента, поэтому

```
my-len([list: 8, 9]) is 2
```

Первый элемент _этого_ списка --- число `8`, остальные элементы --- список
`[list: 9]`.

```
my-len([list: 9]) is 1
```

Все элементы данного списка без первого элемента образуют, очевидно, пустой
список --- `empty`, чья длина равна нулю. Составляя вместе все эти примеры, получаем:

```
my-len([list: 7, 8, 9]) is 3
my-len([list:    8, 9]) is 2
my-len([list:       9]) is 1
my-len([list:        ]) is 0
```

Можно переписать эти примеры несколько иным способом:

```
my-len([list: 7, 8, 9]) is 1 + 2
my-len([list:    8, 9]) is 1 + 1
my-len([list:       9]) is 1 + 0
my-len([list:        ]) is     0
```

Глядя на примеры, записанные таким способом, можно увидеть закономерность.
Длина пустого списка равна `0`. Длина непустого списка равна сумме единицы `1`
(«вклад» первого элемента в общую длину списка) и длины списка, состоящего из
остальных элементов. Таким образом

```
my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list:    8, 9]) is 1 + my-len([list:    9])
my-len([list:       9]) is 1 + my-len([list:     ])
my-len([list:        ]) is 0
```

Т. е. мы можем использовать результат вычисления длины списка без первого
элемента для вычисления длины всего списка.

TODO

### 5.3.2 `my-sum`: Примеры

Ту же самую логику мы применяем для анализа `my-sum`. Чему равна сумма
списка `[list: 7, 8, 9]`? Разумеется, нам бы хотелось, чтобы она была равна
`24`. Согласимся также и с тем, что сумма `[list: 8, 9]` равна `17`, а `[list:
9]` --- `9`. Тогда имеем

```
my-sum([list: 7, 8, 9]) is 7 + 8 + 9
my-sum([list:    8, 9]) is     8 + 9
my-sum([list:       9]) is         9
```

что можно также переписать как

```
my-sum([list: 7, 8, 9]) is 7 + my-sum([list: 8, 9])
my-sum([list:    8, 9]) is 8 + my-sum([list:    9])
my-sum([list:       9]) is 9 + my-sum([list:     ])
```

Из последнего примера очевидно следует, что `my-sum([list: ])` равно
нулю

```
my-sum([list: ]) is 0
```

### 5.3.3 От Примеров к Коду

Получившиеся примеры мы можем теперь обратить в код. Для этого мы введём
конструкцию **cases**, с помощью которой мы можем различать разные виды списков
и выбирать на основе этих различий выражения, которые должны быть исполнены.

Шаблон `cases` для списков выглядит так:

```
cases (List) lst:
  | empty          => ...
  | link(fst, rst) => ... fst ... rst ...
end
```

большая часть этого кода остаётся неизменной при каждом использовании. Изменять
здесь вы можете 

- `lst` --- выражение, чьим значением должен быть список; это должна быть либо
  переменная, связанная со списком, либо комплексное выражение, которое
  вычисляется до списка;

- `fst` и `rst` --- имена для первого элемента и остальных элементов списка. Вы
  можете выбрать любые имена, какие вам хочется, однако в Pyret принято
  записывать их как `fst` и `rst` либо как `f` и `r` соответственно.

Справа от каждого `=>` записано выражение.

В данном случае `cases` работает следующим образом. Pyret сперва вычисляет
значение `lst`. Затем он проверяет, действительно ли получившееся значение
является списком; если это не так, то выполнение программы прерывается вызовом
ошибки. Если данное значение является списком, Pyret определяет, какой _вид_ у
этого списка. Если это пустой список, то выполняется выражение справа от `=>`
там, где слева от `=>` написано `empty`. Если это непустой список, то Pyret
связывает `fst` и `rst` соответственно с первым элементом и остальными
элементами этого непустого списка, и затем выполняет выражение справа от `=>` в
пункте с `link`.

Используем теперь `cases` для определения `my-len`:

```
fun my-len(lst):
  cases (List) lst:
    | empty          => 0
    | link(fst, rst) => 1 + my-len(rst)
  end
end
```

этот код явно следует из наших примеров: когда список пустой, `my-len`
возвращает `0`; когда он непустой, мы прибавляем единицу к длине списка без
первого элемента (здесь он обозначен через `rst`)

Аналогично определим `my-sum`:

```
fun my-sum(lst):
  cases (List) lst:
    | empty          => 0
    | link(fst, rst) => fst + my-sum(rst)
  end
end
```

## 5.4 Структурные Задачи с Ответом в Виде Списка TODO

Теперь давайте займёмся функциями, которые должны производить список в качестве
ответа.

### 5.4.1 `my-str-len`: Примеры и Код

Как обычно, начнём с примеров. Получая список строк, мы хотим из него сделать
список длин этих строк (в том же самом порядке). Допустим, есть такой пример:

```
my-str-len([list: "hi", "there", "mateys"]) is [list: 2, 5, 6]
```

ответы для подзадач будут такими:


```
my-str-len([list:       "there", "mateys"]) is [list:    5, 6]
my-str-len([list:                "mateys"]) is [list:       6]
```

или, другими словами, 

```
my-str-len([list: "hi", "there", "mateys"]) is link(2, [list: 5, 6])
my-str-len([list:       "there", "mateys"]) is link(5, [list:    6])
my-str-len([list:                "mateys"]) is link(6, [list:     ])
```

из чего следует, что ответом на пустой список должен быть пустой список:

```
my-str-len(empty) is empty
```

Эти ответы мы можем получить применяя `string-length` последовательно к каждому
элементу списка:

```
fun my-str-len(lst):
  cases (List) lst:
    | empty => empty
    | link(fst, rst) =>
      link(string-length(fst), my-str-len(rst))
  end
end
```

### 5.4.2 `my-pos-nums`: Примеры и Код

И снова начнём с примеров:

```
my-pos-nums([list: 1, -2, 3, -4]) is [list: 1, 3]
my-pos-nums([list:    -2, 3, -4]) is [list:    3]
my-pos-nums([list:        3, -4]) is [list:    3]
my-pos-nums([list:           -4]) is [list:     ]
my-pos-nums([list:             ]) is [list:     ]
```

Можно переписать их с использованием `link`:

```
my-pos-nums([list: 1, -2, 3, -4]) is link(1, [list: 3])
my-pos-nums([list:    -2, 3, -4]) is         [list: 3]
my-pos-nums([list:        3, -4]) is link(3, [list: ])
my-pos-nums([list:           -4]) is         [list: ]
my-pos-nums([list:             ]) is         [list: ]
```

или, более явно,

```
my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])
my-pos-nums([list:             ]) is         [list: ]
```

Т. е. когда первый элемент положителен, мы добавляем его к результату
вычисления `my-pos-nums` на остальных элементах; когда первый элемент
отрицателен, мы берём лишь результат вычисления `my-pos-nums` на остальных
элементах. Это даёт нам следующий код:

```
fun my-pos-nums(lst):
  cases (List) lst:
    | empty => empty
    | link(fst, rst) =>
      if fst > 0:
        link(fst, my-pos-nums(rst))
      else:
        my-pos-nums(rst)
      end
  end
end
```

Является ли наш набор примеров исчерпывающим? Не вполне. Есть ещё много
примеров, которые мы не рассматривали: списки, оканчивающиеся положительными
числами, списки с `0` внутри. 

_Упражнение: разберите эти примеры и сравните правильные ответы с теми, которые
будет выдавать программа._

### 5.4.3 `my-alternating`: Попытка Первая

Итак, примеры:

```
check:
  my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
  my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
  my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
  my-alternating([list:          4, 5, 6]) is [list:    4, 6]
end
```

Внимательно посмотрите на первые два. Каждый из них записан правильно, но
_второй ответ никак не помогет нам получить первый_. Это может означать, что
способа, которым мы решали задачи до этого момента, недостаточно, и здесь ещё
есть, над чем подумать. Вернёмся к этой задаче позже.

### 5.4.4 `my-running-sum`: Попытка Первая

И ещё раз начинаем с примеров. Запишем первые три:

```
check:
  my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
  my-running-sum([list:    2, 3, 4, 5]) is [list: 2, 5, 9, 14]
  my-running-sum([list:       3, 4, 5]) is [list: 3,  7, 12]
end
```

здесь снова не видно ясной связи между первыми двумя ответами. Эту задачу мы также
пока пропускаем.

## 5.5 Структурные Задачи с ... TODO

### 5.5.1 `my-max`: Примеры

Давайте теперь найдём максимальное значение в списке. Для простоты будем
считать, что список --- это список чисел. Примеры каких списков нам нужно
построить? Сначала, конечно, пустой и непустой списки. А что ещё? Будет ли
`[list: 1, 2, 3]` хорошим примером? Этот пример подойдёт, но нам также
следует рассмотреть списки, где максимум находится в начале списка, а не в
конце; максимум может быть в середине; максимум может встречаться в списке
более одного раза; максимум может быть отрицательным числом; и т. д. 

```
my-max([list: 1, 2, 3]) is 3
my-max([list: 3, 2, 1]) is 3
my-max([list: 2, 3, 1]) is 3
my-max([list: 2, 3, 1, 3, 2]) is 3
my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list: -2, -1, -3]) is -1
```

Как определить `my-max(empty)`? Будет ли оно равно нулю?

Вернёмся к этому вопросу позже.

Перед тем как продолжить, полезно узнать, что существует такая функция как
`num-max`, которая уже есть в Pyret, сравнивающая два числа

```
num-max(1, 2) is 2
num-max(-1, -2) is -1
```

Посмотрим теперь на `my-max` в действии:

```
my-max([list: 1, 2, 3]) is 3
my-max([list:    2, 3]) is 3
my-max([list:       3]) is 3
```

Кажется, этот пример никак не приближает нас к решению. И мы всё ещё не знаем,
что делать с `empty`.

Следующий пример

```
my-max([list: 3, 2, 1]) is 3
my-max([list:    2, 1]) is 2
my-max([list:       1]) is 1
```

также не сообщает нам ничего о том, как может выглядеть потенциальное решение.
Возможно, мы не видим общей закономерности из-за неудачного --- или, точнее
сказать, неполного --- набора примеров.

Давайте посмотрим на ещё один

```
my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list:    1, 4, 3, 2]) is 4
my-max([list:       4, 3, 2]) is 4
my-max([list:          3, 2]) is 3
my-max([list:             2]) is 2
```

Обратите внимание, как, вычисляя максимум списка без первого элемента, мы
получаем один из двух аргументов для `num-max`, а сравнивая его и первый элемент,
получаем конечный ответ.

```
my-max([list: 2, 1, 4, 3, 2]) is num-max(2, 4)
my-max([list:    1, 4, 3, 2]) is num-max(1, 4)
my-max([list:       4, 3, 2]) is num-max(4, 3)
my-max([list:          3, 2]) is num-max(3, 2)
my-max([list:             2]) is ...
```

Последний пример можно было бы записать как

```
my-max([list:             2]) is num-max(2, ...)
```

однако мы не знаем, что есть максимум (или минимум, или любой другой элемент)
пустого списка. Поэтому, пропуская последний пример, имеем следующее:

```
my-max([list: 2, 1, 4, 3, 2]) is num-max(2, my-max([list: 1, 4, 3, 2]))
my-max([list:    1, 4, 3, 2]) is num-max(1, my-max([list:    4, 3, 2]))
my-max([list:       4, 3, 2]) is num-max(4, my-max([list:       3, 2]))
my-max([list:          3, 2]) is num-max(3, my-max([list:          2]))
```

Теперь видно, как мы можем использовать ответ для части списка, чтобы получить
ответ для всего списка, который, в свою очередь, может также являться частью
какого-нибудь другого списка, и т. д.

В конце концов, нам надо разобраться с тем, как обрабатывать случай списка
`empty`. Проблема заключается в том, что в пустом списке нет максимального
элемента, т. к. в нём нет вообще никаких элементов. Т. е. бессмысленно задавать
вопрос о максимуме пустого списка: понятие «максимума» определено только для
непустых списков. Поэтому при попытке вычислить максимум пустого списка нам следует 
сообщить об ошибке с помощью `raises`:

```
my-max(empty) raises ""
```

### 5.5.2 `my-max`: От Примеров к Коду

На основе примеров выше мы можем написать такой код:

```
fun my-max(lst):
  cases (List) lst:
    | empty      => raise("не определено для пустых списков")
    | link(fst, rst) => num-max(fst, my-max(rst))
  end
end
```

Рассмотрим пример со списком `[list: 2]`. При выполнении `my-max([list: 2])`
программа попытается вычислить `num-max(2, my-max([list: ]))`, что, очевидно,
приведёт к ошибке. Таким образом, ни на каком непустом списке наша функция
работать не будет. Чтобы это исправить, нам нужно правильно определять, не
пытаемся ли мы найти максимум в пустом списке. Сделать это можно двумя
способами. О первом из них пойдёт речь прямо сейчас, а другой мы обсудим
позднее.

Обращаясь вновь к примерам, мы видим, что, перед тем как выполнять `my-max(rst)`,
нам нужно проверить, является ли `rst` из `link(fst, rst)` пустым списком. Если он
пуст, то `my-max` на нём выполнять не следует. Если список `rst` --- `lst` без
первого элемента --- пуст, то максимумом списка `lst` мы считаем его первый и
единственный элемент `fst`:

```
fun my-max(lst):
  cases (List) lst:
    | empty          => raise("не определено для пустых списков")
    | link(fst, rst) =>
      cases (List) rst:
        | empty => fst
        | ...
      end
  end
end
```

Осталось написать, что нужно сделать, если `lst` и `rst` оба непусты. Если
список `lst` непуст, то --- как видно опять же из примеров --- мы должны вычислить
максимум списка `rst` и сравнить его с первым элементом --- `fst`:

```
fun my-max(lst):
  cases (List) lst:
    | empty          => raise("не определено для пустых списков")
    | link(fst, rst) =>
      cases (List) rst:
        | empty => fst
        | else  => num-max(fst, my-max(rst))
      end
  end
end
```

_Упражнение: убедитесь в правильности этого определения._

### 5.5.3 `my-alternating`: Примеры и Код


